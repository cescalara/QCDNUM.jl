var documenterSearchIndex = {"docs":
[{"location":"functions/#Available-functions","page":"Available functions","title":"Available functions","text":"","category":"section"},{"location":"functions/","page":"Available functions","title":"Available functions","text":"The dcoumentation of all available functions is listed below in alphabetical order. Documentation can also be found using the search bar on the left, or via the Julia REPL, e.g:","category":"page"},{"location":"functions/","page":"Available functions","title":"Available functions","text":"julia> using QCDNUM\n\njulia> ?QCDNUM.evsgns","category":"page"},{"location":"functions/#Module-documentation","page":"Available functions","title":"Module documentation","text":"","category":"section"},{"location":"functions/","page":"Available functions","title":"Available functions","text":"Modules = [QCDNUM]","category":"page"},{"location":"functions/#QCDNUM.EvolutionParams","page":"Available functions","title":"QCDNUM.EvolutionParams","text":"EvolutionParams\n\nStruct for holding all QCDNUM Parameters. \n\n\n\n\n\n","category":"type"},{"location":"functions/#QCDNUM.GridParams","page":"Available functions","title":"QCDNUM.GridParams","text":"GridParams\n\nStruct for holding the QCDNUM grid parameters.\n\n\n\n\n\n","category":"type"},{"location":"functions/#QCDNUM.InputPDF","page":"Available functions","title":"QCDNUM.InputPDF","text":"InputPDF\n\nStruct containing all necessary info to pass a PDF  (parton distribution function) into QCDNUM.\n\n\n\n\n\n","category":"type"},{"location":"functions/#QCDNUM.SPLINTParams","page":"Available functions","title":"QCDNUM.SPLINTParams","text":"SPLINTParams\n\nStruct for storage of parameters used with SPLINT package of QCDNUM.\n\n\n\n\n\n","category":"type"},{"location":"functions/#QCDNUM.SplineAddresses","page":"Available functions","title":"QCDNUM.SplineAddresses","text":"SplineAddresses\n\nLookup table for addresses of different  structure function splines.\n\n\n\n\n\n","category":"type"},{"location":"functions/#QCDNUM.allfij-NTuple{5, Integer}","page":"Available functions","title":"QCDNUM.allfij","text":"allfij(iset, ix, iq, n, ichk)\n\nGet all flavour-pdf values for given ix and iq grid points.\n\nArguments\n\niset::Integer: pdf set id (1-24).\nix::Integer: x grid point.\niq::Integer: q2 grid point.\nn::Integer: number of additional pdfs to be returned.\nichk::Integer: flag to steer error checking. See QCDNUM \n\ndocs. ichk = -1 makes code faster, at the risk of not  checking certain things.\n\nReturns\n\npdf::Array{Float64,2}: pdf values over flavours.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.allfxq-Tuple{Integer, Float64, Float64, Integer, Integer}","page":"Available functions","title":"QCDNUM.allfxq","text":"allfxq(iset, x, qmu2, n, ichk)\n\nGet all flavour-pdf values for a given x and mu^2.\n\nArguments\n\niset::Integer: pdf set id (1-24).\nx::Float64: input value of x.\nqmu2::Float64: input value of qmu2.\nn::Integer: number of additional pdfs to be returned.\nichk::Integer: flag to steer error checking. See QCDNUM \n\ndocs. ichk = -1 makes code faster, at the risk of not  checking certain things.\n\nReturns\n\npdf::Array{Float64,2}: pdf values over flavours.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.altabn-Tuple{Integer, Integer, Integer}","page":"Available functions","title":"QCDNUM.altabn","text":"altabn(iset, iq, n)\n\nReturns the value of (alphaS / 2pi)^n, properly truncated, at the  factorisation scale muF^2.\n\nArguments\n\niset::Integer: identifier of tha active alpha_S table (0) or pdf set (1-24).\niq::Integer: index of q2 grid point\nn::Integer: power of alpha_S for the different perturbative series.\n\nReturns\n\nasn::Float64: value of (alpha_S / 2pi)^n, 0 if error.\nierr::Integer: set, on exit, to 1 if iq is close to or below the value of \n\nLambda^2, and to 2 if iq is outside the grid boundaries. \n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.asfunc-Tuple{Float64}","page":"Available functions","title":"QCDNUM.asfunc","text":"asfunc(r2)\n\nEvolve alpha_S(mu_R^2). Does not use mu^2 grid or weight tables.\n\nReturns\n\nalphas::FLoat64: alpha_S value.\nnf::Integer: number of flavours at scale r2.\nierr::Integer: error code\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.bvalij-NTuple{5, Integer}","page":"Available functions","title":"QCDNUM.bvalij","text":"bvalij(iset, id, ix, iq, ichk)\n\nGet the value of a basis pdf at a given point (ix, iq).\n\nArguments\n\niset::Integer: pdf set id (1-24)\nid::Integer: basis pdf identifier from 0 to 12+n, \n\nwhere n is the number of additional pdfs in iset.\n\nix::Integer: x index.\niq::Integer: qq index.\nichk::Integer: flag to steer error checking. \n\nSee allfxq().\n\nReturns\n\npdf::Float64: pdf values.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.bvalxq-Tuple{Integer, Integer, Float64, Float64, Integer}","page":"Available functions","title":"QCDNUM.bvalxq","text":"bvalxq(iset, id, x, qq, ichk)\n\nGet the value of a basis pdf at a given point (x, qq).\n\nArguments\n\niset::Integer: pdf set id (1-24)\nid::Integer: basis pdf identifier from 0 to 12+n, \n\nwhere n is the number of additional pdfs in iset.\n\nx::Float64: x value.\nqq::Float64: qq value.\nichk::Integer: flag to steer error checking. \n\nSee allfxq().\n\nReturns\n\npdf::Float64: pdf values.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.cpypar-Tuple{Integer}","page":"Available functions","title":"QCDNUM.cpypar","text":"cpypar(iset)\n\nCopy the evolution parameters of a pdf set to a local array. The array has the following param values:\n\n1: iord \n2: alfas \n3: r2alf \n4: nfix \n5: q2c\n6: q2b\n7: q2t \n8: ar \n9: br \n10:xmin\n11:qmin \n12:qmax \n\nIn addition to the evolution parameters is given the pdf type in array(13):  1 = unpolarised, 2 = polarised, 3 = time-like, 4 = external, 5 = user.\n\nArguments\n\niset::Integer: pdf set identifier. \n\nReturns\n\narray::Vector{Float64}\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.dmpwgt-Tuple{Integer, Integer, String}","page":"Available functions","title":"QCDNUM.dmpwgt","text":"dmpwgt(itype, lun, filename)\n\nDump weight tables of a given itype to filename.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.dsp_funs1-Tuple{Integer, Float64, Integer}","page":"Available functions","title":"QCDNUM.dsp_funs1","text":"dsp_funs1(ia, u, ichk)\n\nEvaluate function for 1D spline.\n\nPossible values of ichk:\n\n-1: extrapolate the spline\n0: return 0\n1: throw an error message\n\nArguments\n\nia::Integer: address of spline\nu::Float64: x or qq\nichk::Integer: defines behaviour when outside \n\nspline range\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.dsp_funs2-Tuple{Integer, Float64, Float64, Integer}","page":"Available functions","title":"QCDNUM.dsp_funs2","text":"dsp_funs2(ia, x, q, ichk)\n\nEvaluate function for 2D spline.\n\nPossible values of ichk:\n\n-1: extrapolate the spline\n0: return 0\n1: throw an error message\n\nArguments\n\nia::Integer: address of spline\nx::Float64: x value\nq::Float64: qq value\nichk::Integer: defines behaviour when outside \n\nspline range\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.dsp_ints1-Tuple{Integer, Float64, Float64}","page":"Available functions","title":"QCDNUM.dsp_ints1","text":"dsp_ints1(ia, u1, u2)\n\nEvaluate integral of spline between u1 and u2.\n\nThe integration limits must lie inside the  spline range. \n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.dsp_ints2-Tuple{Integer, Float64, Float64, Float64, Float64, Float64, Integer}","page":"Available functions","title":"QCDNUM.dsp_ints2","text":"dsp_ints2(ia, x1, x2, q1, q2, rs, np)\n\nEvaluate integral of spline between x1, x2, q1 and q2. Also takes care of rscut and integrations makes use of N-point  Gauss quadrature, as defined by the choice of np.\n\nThe integration limits must lie inside the  spline range.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.dsp_rscut-Tuple{Integer}","page":"Available functions","title":"QCDNUM.dsp_rscut","text":"dsp_rscut(ia)\n\nGet the root(s) cut for the spline at ia.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.dsp_rsmax-Tuple{Integer, Float64}","page":"Available functions","title":"QCDNUM.dsp_rsmax","text":"dsp_rsmax(ia, rsc)\n\nGet the root(s) cut limit for the spline at ia and cut rsc.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.dsp_spgetval-Tuple{Integer, Integer}","page":"Available functions","title":"QCDNUM.dsp_spgetval","text":"dsp_spsgtval(ia, i)\n\nGet some extra info, val, from the spline ia.\n\nArguments\n\nia::Integer: spline address.\ni::Integer: storage index, runs from 1-100.\n\nReturns\n\nval::Float64: value to store.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.dsp_uread-Tuple{Integer}","page":"Available functions","title":"QCDNUM.dsp_uread","text":"dsp_uread(i)\n\nRead something from the reserved user space.\n\nArguments\n\ni::Integer: where to read, from 1 to nuser\n\nReturns\n\nval::Float64: what is read\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.evolfg-Tuple{Integer, Union{Ptr{Nothing}, Base.CFunction}, Array{Float64, N} where N, Integer}","page":"Available functions","title":"QCDNUM.evolfg","text":"evolfg(itype, func, def, iq0)\n\nEvolve the flavour pdf set.\n\nArguments\n\nitype::Integer: select un-polarised (1), polarised (2) or \n\ntime-like (3) evolution.\n\nfunc::Union{Base.CFunction, Ptr{Nothing}}: User-defined function \n\nthat returns input x * f_j(x) at iq0. j is from 0 to 2 * nf.\n\ndef::Array{Float64}: input array containing the contribution of \n\nquark species i to the input distribution j.\n\niq0::Integer: grid index of the starting scale mu_0^2.\n\nReturns\n\nepsi::Float64: max deviation of the quadratic spline interpolation \n\nfrom linear interpolation mid-between grid points.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.evolve-Tuple{QCDNUM.InputPDF, EvolutionParams}","page":"Available functions","title":"QCDNUM.evolve","text":"evolve(input_pdf, qcdnum_params)\n\nHigh-level interface to QCD evolution with QCDNUM.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.evsgns-Tuple{Integer, Union{Ptr{Nothing}, Base.CFunction}, Vector{Int32}, Integer, Integer}","page":"Available functions","title":"QCDNUM.evsgns","text":"evsgns(itype, func, isns, n, iq0)\n\nEvolve an arbitrary set of single/non-singlet pdfs. The  evolution can only run in FFNS or MFNS mode, as it is not  possible to correctly match at the thresholds as in evolfg.\n\nArguments\n\nThe arguments are as for evolfg, expect def::Array{Float64} is replaced with:\n\nisns::Array{Int32,1}: Input int array specifing the \n\nevolution type. Entries can be (+1, -1, +-2) corresponding to  singlet, valence non-singlet and +/- q_ns singlets respectively. \n\nn::Integer: Number of singlet/non-singlet pdfs to evolve \n\nReturns\n\nepsi::Float64: Maximum deviation of the quadratic spline from \n\nlinear interpolation mid-between the grid points.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.extpdf-Tuple{Union{Ptr{Nothing}, Base.CFunction}, Integer, Integer, Float64}","page":"Available functions","title":"QCDNUM.extpdf","text":"extpdf(fun, iset, n, offset)\n\nImport a pdfset from an external source.\n\nArguments\n\nfun::Union{Base.CFunction, Ptr{Nothing}}: User-defined function with the signature \n\nfun(ipdf::Integer, x::Float64, qq::Float64, first::UInt8)::Float64 specifying the values at x and qq of pdfset ipdf.\n\niset::Integer: Pdfset identifier, between 1 and 24.\nn::Integer: Number of pdf tables in addition to gluon tables.\noffset::Float64: Relative offset at the thresholds mu_h^2, used \n\nto catch matching discontinuities.\n\nReturns\n\nepsi::Float64: Maximum deviation of the quadratic spline from \n\nlinear interpolation mid-between the grid points.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.fflist-Tuple{Integer, Array{Float64, N} where N, Integer, Array{Float64, N} where N, Array{Float64, N} where N, Integer}","page":"Available functions","title":"QCDNUM.fflist","text":"fflist(iset, c, isel, x, q, ichk)\n\nA fast routine to generate a list of interpolated pdfs.\n\nArguments\n\niset::Integer: pdf set identifier [1-24]\nc::Array{Float64}: coefficients of quarks/anti-quarks\nisel::Integer: selection flag\nx::Array{Float64}: list of x values.\nq::Array{Float64}: list of q2 values.\nichk::Integer: flag to steer error checking. See allfxq().\n\nReturns\n\nf::Array{Float64}: output list of pdf values.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ffromr-Tuple{Float64}","page":"Available functions","title":"QCDNUM.ffromr","text":"rfromf(fscale2)\n\nConvert the renormalisation scale, muR^2, to the factorisation scale, muF^2. \n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.fillwt-Tuple{Integer}","page":"Available functions","title":"QCDNUM.fillwt","text":"fillwt(itype)\n\nFill weight tables for all order and number of flavours. itype is used to select un-polarised pdfs (1), polarised  pdfs (2) or fragmentation functions (3).\n\nReturns\n\nnwds::Integer: number of words used in memory.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.fsplne-Tuple{Integer, Integer, Float64, Integer}","page":"Available functions","title":"QCDNUM.fsplne","text":"fsplne(iset, id, x, iq)\n\nSpline interpolation of a basis PDF in x, at the grid point iq. Provided as a diagnostic tool to investigate possible quadratic spline oscillations.\n\nArguments\n\niset::Integer: PDF set identifier [1-24] id::Integer: Identifier of a basis pdf |e^±| x::Float64: x value iq::Integer: Index of a Q^2 grid point\n\nReturns\n\npdf::Float64: pdf value\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ftable-Tuple{Integer, Array{Float64, N} where N, Integer, Array{Float64, N} where N, Array{Float64, N} where N, Integer}","page":"Available functions","title":"QCDNUM.ftable","text":"fftabl(ist, c, isel, x, q, n, ichk)\n\nA fast routine to generate a table of interpolated pdfs.\n\niset::Integer: pdf set identifier [1-24]\nc::Array{Float64}: coefficients of quarks/anti-quarks\nisel::Integer: selection flag\nx::Array{Float64}: list of x values.\nq::Array{Float64}: list of q2 values.\nichk::Integer: flag to steer error checking. See allfxq().\n\nReturns\n\ntable::Matrix{Float64}: output table of pdf values.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.fvalij-NTuple{5, Integer}","page":"Available functions","title":"QCDNUM.fvalij","text":"fvalij(iset, id, ix, iq, ichk)\n\nGet the value of a flavour momentum density  at a given point (ix, iq).\n\nArguments\n\niset::Integer: pdf set id (1-24)\nid::Integer: basis pdf identifier from -6 to 6+n, \n\nwhere n is the number of additional pdfs in iset.\n\nix::Integer: x index.\niq::Intger: qq index.\nichk::Integer: flag to steer error checking. \n\nSee allfxq().\n\nReturns\n\npdf::Float64: pdf values.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.fvalxq-Tuple{Integer, Integer, Float64, Float64, Integer}","page":"Available functions","title":"QCDNUM.fvalxq","text":"fvalxq(iset, id, x, qq, ichk)\n\nGet the value of a flavour momentum density at a given point (x, qq).\n\nArguments\n\niset::Integer: pdf set id (1-24)\nid::Integer: basis pdf identifier from -6 to 6+n, \n\nwhere n is the number of additional pdfs in iset.\n\nx::Float64: x value.\nqq::Float64: qq value.\nichk::Integer: flag to steer error checking. \n\nSee allfxq().\n\nReturns\n\npdf::Float64: pdf values.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.getabr-Tuple{}","page":"Available functions","title":"QCDNUM.getabr","text":"getabr()\n\nGet the relation between the factorisation scale muF^2 and the renormalisation scale muR^2.\n\nmuR^2 = ar muF^2 + br.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.getalf-Tuple{}","page":"Available functions","title":"QCDNUM.getalf","text":"getalf()\n\nSet the starting value of alpha_S and the starting  renormalisation scale r2. By default alpha_S(m_Z^2) = 0.118.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.getcbt-Tuple{}","page":"Available functions","title":"QCDNUM.getcbt","text":"getcbt()\n\nReturn the current threshold settings for the FFNS or VFNS.\n\nReturns\n\nnfix::Integer: number of flavours in the FFNS. For VNFS set\n\nnfix = 0.\n\nqc/b/t::Float64: q2 values of the heavy flavour thresholds \n\nin the VFNS. Ignored if FFNS.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.getint-Tuple{String}","page":"Available functions","title":"QCDNUM.getint","text":"getint(param)\n\nGet QCDNUM integer parameters.\n\nArguments\n\nparam::String: Name of parameter. Can be \"iter\" (number of \n\nevolutions in backwards iteration), \"tlmc\" (time-like matching  conditions), \"nopt\" (number of perturbative terms) or \"edbg\"  (evolution loop debug printout).\n\nReturns\n\nival::Int32: Integer value that is read\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.getlim-Tuple{Integer}","page":"Available functions","title":"QCDNUM.getlim","text":"getlim(iset)\n\nRead current grid boundary values for a pdf set iset.\n\nReturns\n\nxmin::Float64: min x boundary\nqmin::Float64: min q2 boundary\nqmax::Float64: max q2 boundary\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.getord-Tuple{}","page":"Available functions","title":"QCDNUM.getord","text":"getord()\n\nGet order of perturbative QCD calculations. iord = 1, 2, 3 for LO, NLO and NNLO respectively. By default, iord = 2.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.getval-Tuple{String}","page":"Available functions","title":"QCDNUM.getval","text":"getval(param)\n\nGet QCDNUM parameters.\n\nArguments\n\nparam::String: Name of parameter. Can be \"null\" (result of \n\ncalc that cannot be performed), \"epsi\" (tolerance level in float comparison |x-y| < epsi), \"epsg\" (numerical accuracy of Gauss  integration in weight table calc), \"elim\" (allowed diff between  quadratic and linear spline interpolation mid-between x grid  points - to disable, set elim<=0), \"alim\" (Max allowed value of  alpha_s(mu^2)), \"qmin\" (smallest possible boundary of mu^2 grid) \"qmax\" (largest possible boundary of mu^2 grid).\n\nReturns\n\nval::Float64: Value.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.gqcopy-Tuple{Integer}","page":"Available functions","title":"QCDNUM.gqcopy","text":"gqcopy(n)\n\nCopy the current mu^2 grid into an array of length n. \n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.gqmake-Tuple{Vector{Float64}, Vector{Float64}, Integer, Integer}","page":"Available functions","title":"QCDNUM.gqmake","text":"gqmake(qarr, wgt, n, nqin)\n\nDefine a logarithmically-spaced mu_F^2 grid on which the parton densities are evolved.\n\nArguments\n\nqarr::Array{Float64,1}: input array containing n values of mu^2\n\nin ascending order. The lower edge of the grid should be above 0.1 GeV^2.\n\nwgt::Array{Float64,1}: relative grip point density in each region\n\ndefined by qarr.\n\nn::Integer: number of values in qarr and wgt (n>=2).\nnqin::Integer: requested number of grid points.\n\nReturns\n\nnqout::Integer: number of generated grid points.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.grpars-Tuple{}","page":"Available functions","title":"QCDNUM.grpars","text":"grpars()\n\nGet the current grid definitions.\n\nReturns\n\nnx::Integer: number of points in x grid. xmi::Float64: lower boundary of x grid. xma::Float64: upper boundary of x grid. nq::Integer: number of points in qq grid. qmi::Float64: lower boundary of qq grid. qma::Float64: upper boundary of qq grid. iord::Integer: order of spline interpolation.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.gxcopy-Tuple{Integer}","page":"Available functions","title":"QCDNUM.gxcopy","text":"gxcopy(n)\n\nCopy the current x grid into an array of length n. \n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.gxmake-Tuple{Vector{Float64}, Vector{Int32}, Integer, Integer, Integer}","page":"Available functions","title":"QCDNUM.gxmake","text":"gxmake(xmin, iwt, n, nxin, iord)\n\nDefine a logarithmically-spaced x grid.\n\nArguments\n\nxmin::Array{Float64,1}: an input array containitn n values \n\nof x in ascending order. xmin[1] defines the lower end of the grid  and other values define approx positions where the point density will change according to the values set in iwt.\n\niwt::Array{Int32,1}: input integer weights given in ascending order \n\nand must always be an integer multiple of the previous weight.\n\nn::Integer: number of values specified in xmin and iwt.\nnxin::Integer: Requested number of grid points.\niord::Integer: iord = 2(3) for linear(quadratic) spline interpolation.\n\nReturns\n\nnxout::Integer: the number of generated grid points. \n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ievtyp-Tuple{Integer}","page":"Available functions","title":"QCDNUM.ievtyp","text":"ievtype(iset)\n\nGet the pdf evolution type for set iset::Integer.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.init-Tuple{}","page":"Available functions","title":"QCDNUM.init","text":"init()\n\nHigh-level default initialisation for QCDNUM.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.iqfrmq-Tuple{Float64}","page":"Available functions","title":"QCDNUM.iqfrmq","text":"iqfrmq(q2)\n\nGet grid point index of the closest grid point at or  below q2 value. \n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.isp_s2make-Tuple{Integer, Integer}","page":"Available functions","title":"QCDNUM.isp_s2make","text":"isp_s2make(istepx, istepq)\n\nCreate a spline object in memory, and return the address. Every istep-th grid point is taken as a node point of the  spline and the grid boundaries are always included as node points.\n\nArguments\n\nistepx::Integer: steps taken in sampling the QCDNUM x grid\nistepq::Integer: steps taken in sampling the QCDNUM qq grid\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.isp_s2user-Tuple{Array{Float64, N} where N, Integer, Array{Float64, N} where N, Integer}","page":"Available functions","title":"QCDNUM.isp_s2user","text":"isp_s2user(xarr, nx, qarr, nq)\n\nSet your own node points in the spline in case the automatic sampling fails.\n\nThe routine will discard points outside the x-qq  evolution grid, round the remaining nodes down to  the nearest grid-point and then sort them in  ascending order, discarding equal values. Thus you are allowed to enter un-sorted scattered arrays.\n\nArguments\n\nxarr::Array{Float64}: array of x values\nnx::Integer: length of xarr\nqarr::Array{Float64}: array of qq values\nnq::Integer: length of qarr\n\nReturns\n\niasp::Integer: address of the spline object\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.isp_splinetype-Tuple{Integer}","page":"Available functions","title":"QCDNUM.isp_splinetype","text":"isp_splinetype(ia)\n\nGet the type of spline at address ia.\n\nPossible types are:\n\n-1: x spline\n0: not a spline\n1: qq spline\n2: x-qq spline \n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.isp_spread-Tuple{String}","page":"Available functions","title":"QCDNUM.isp_spread","text":"ssp_spread(filename)\n\nRead spline from filename and return address ia.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.isp_spsize-Tuple{Integer}","page":"Available functions","title":"QCDNUM.isp_spsize","text":"isp_spsize(ia)\n\nGet used space for spline ia, or total memory size when  ia = 0.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.isp_spvers-Tuple{}","page":"Available functions","title":"QCDNUM.isp_spvers","text":"isp_spvers()\n\nSPLINT version as a date.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.isp_sqmake-Tuple{Integer}","page":"Available functions","title":"QCDNUM.isp_sqmake","text":"isp_sqmake(istepq)\n\nCreate a 1D qq spline object in memory, and return the address. Every istep-th grid point is taken as a node point of the  spline and the grid boundaries are always included as node points.\n\nArguments\n\nistepq::Integer: steps taken in sampling the QCDNUM qq grid\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.isp_squser-Tuple{Array{Float64, N} where N, Integer}","page":"Available functions","title":"QCDNUM.isp_squser","text":"isp_squser(qarr, nq)\n\nSet your own node points in the 1D qq spline in case the automatic sampling fails.\n\nArguments\n\nqarr::Array{Float64}: array of qq values\nnq::Integer: length of qarr\n\nReturns\n\niasp::Integer: address of the spline object\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.isp_sxmake-Tuple{Integer}","page":"Available functions","title":"QCDNUM.isp_sxmake","text":"isp_sxmake(istepx)\n\nCreate a 1D x spline object in memory, and return the address. Every istep-th grid point is taken as a node point of the  spline and the grid boundaries are always included as node points.\n\nArguments\n\nistepx::Integer: steps taken in sampling the QCDNUM x grid\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.isp_sxuser-Tuple{Array{Float64, N} where N, Integer}","page":"Available functions","title":"QCDNUM.isp_sxuser","text":"isp_sxuser(xarr, nx)\n\nSet your own node points in the 1D x spline in case the automatic sampling fails.\n\nArguments\n\nxarr::Array{Float64}: array of x values\nnx::Integer: length of xarr\n\nReturns\n\niasp::Integer: address of the spline object\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ixfrmx-Tuple{Float64}","page":"Available functions","title":"QCDNUM.ixfrmx","text":"ixfrmx(x)\n\nGet grid point index of closest grid point at or  below x value.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.keygrp-Tuple{Integer, Integer}","page":"Available functions","title":"QCDNUM.keygrp","text":"keygrp(iset, igroup)\n\nReturns the parameter key of the pdf group in iset. Useful to check if parameters match. Like a more specific keypar.\n\nigroup can be:\n\n1: order\n2: alpha_S\n3: fnsandthresholds\n4: scale\n5: cutes\n6: all\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.keypar-Tuple{Integer}","page":"Available functions","title":"QCDNUM.keypar","text":"keypar(iset)\n\nReturns the parameter key of the pdf in iset. Useful to check if parameters match with.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.load_params-Tuple{String}","page":"Available functions","title":"QCDNUM.load_params","text":"load_params(file_name)\n\nLoad stored QCDNUM or SPLINT parameters.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.make_grid-Tuple{GridParams}","page":"Available functions","title":"QCDNUM.make_grid","text":"make_grid(grid_params)\n\nHigh-level interface to build QCDNUM grid from GridParams.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.mixfns-Tuple{Integer, Float64, Float64, Float64}","page":"Available functions","title":"QCDNUM.mixfns","text":"mixfns(nfix, r2c, r2b, r2t)\n\nSelect the MFNS mode and set thresholds on mu_R^2.\n\nArguments\n\nnfix::Integer: Fixed number of flavours for MFNS. Can be \n\nin the range [3, 6].\n\nr2c/b/t::Float64: Thresholds defined on the renormalisation scale\n\nmu_R^2 for c, b and t.   \n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.nfrmiq-Tuple{Integer, Integer}","page":"Available functions","title":"QCDNUM.nfrmiq","text":"nfrmiq(iset, iq)\n\nReturns the number of active flavours nf at a  q2 grid point iq.\n\nArguments\n\niset::Integer: pdf set identifier.\niq::Integer: q2 grid point.\n\nReturns\n\nnf::Integer: number of active flavours. 0 if iq is \n\noutside the q2 grid.\n\nithresh::Integer: threshold indicator that is set to\n\n+1(-1) if iq is at a threshold with the larger (smaller) number of flavours, 0 otherwise. \n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.nptabs-Tuple{Integer}","page":"Available functions","title":"QCDNUM.nptabs","text":"nptabs(iset)\n\nGet the number of pdf tables in set iset::Integer.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.nwused-Tuple{}","page":"Available functions","title":"QCDNUM.nwused","text":"nwused()\n\nReturns the szie nwtot of the QCDNUM store (the parameter nwf0 in qcdnum.inc) and the number of words used, nwuse.\n\nThe output argument ndummy is not used at present.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.nxtlun-Tuple{Integer}","page":"Available functions","title":"QCDNUM.nxtlun","text":"nxtlun(lmin)\n\nGet next free logical unit number above max(lmin, 10).  Returns 0 if there is no free logical unit. Can be called  before or after qcinit. Handy if you want to open a file  on a unit that is guaranteed to be free.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.pdfcpy-Tuple{Integer, Integer}","page":"Available functions","title":"QCDNUM.pdfcpy","text":"pdfcpy(iset1, iset2)\n\nCopy pdf set.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.pullcp-Tuple{}","page":"Available functions","title":"QCDNUM.pullcp","text":"pushcp()\n\nPull the current parameters from LIFO stack (load stashed parameters).\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.pushcp-Tuple{}","page":"Available functions","title":"QCDNUM.pushcp","text":"pushcp()\n\nPush the current parameters to LIFO stack (temporarily stash them).\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.qcinit-Tuple{Integer, String}","page":"Available functions","title":"QCDNUM.qcinit","text":"qcinit(lun, filename)\n\nInitialise QCDNUM - should be called before anything else. \n\nArguments\n\nlun::Integer: the output logical unit number. When set to 6, \n\nthe QCDNUM messages appear on the standard output. When set to -6,  the QCDNUM banner printout is suppressed.\n\nfilename::String: the output filename to store log. Irrelevant\n\nwhen lun is set to 6/-6\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.qfrmiq-Tuple{Integer}","page":"Available functions","title":"QCDNUM.qfrmiq","text":"qfrmiq(iq)\n\nGet q2 value at grid point iq.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.qqatiq-Tuple{Float64, Integer}","page":"Available functions","title":"QCDNUM.qqatiq","text":"qqatiq(q, iq)\n\nCheck if q2 coincides with a grid point iq.\n\nReturns\n\nout::Bool: true or false\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.qstore-Tuple{String, Integer, Float64}","page":"Available functions","title":"QCDNUM.qstore","text":"qstore(action, i, val)\n\nQCDNUM reserves 500 words of memory for user use. \n\nArguments\n\naction::String: Can be \"write\", \"read\", \"lock\" or \"unlock\".\ni::Integer: Where to read/write in the store.\nval::Float64: What to write in the store.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.qstore-Tuple{String, Integer}","page":"Available functions","title":"QCDNUM.qstore","text":"qstore(action, i)\n\nQCDNUM reserves 500 words of memory for user use. \n\nArguments\n\naction::String: Can be \"write\", \"read\", \"lock\" or \"unlock\".\ni::Integer: Where to read/write in the store.\n\nReturns\n\nval::Float64: What is read from the store.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.readwt-Tuple{Integer, String}","page":"Available functions","title":"QCDNUM.readwt","text":"readwt(lun, filename)\n\nRead weight tables from filename.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.rfromf-Tuple{Float64}","page":"Available functions","title":"QCDNUM.rfromf","text":"rfromf(fscale2)\n\nConvert the factorisation scale, muF^2, to the renormalisation scale, muR^2. \n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.save_params-Tuple{String, Union{EvolutionParams, SPLINTParams}}","page":"Available functions","title":"QCDNUM.save_params","text":"save_params(file_name, params)\n\nStore the QCDNUM or SPLINT parameters for reproducibility.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.setabr-Tuple{Float64, Float64}","page":"Available functions","title":"QCDNUM.setabr","text":"setabr(ar, br)\n\nDefine the relation between the factorisation scale muF^2 and the renormalisation scale muR^2.\n\nmuR^2 = ar muF^2 + br.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.setalf-Tuple{Float64, Float64}","page":"Available functions","title":"QCDNUM.setalf","text":"setalf(alfs, r2)\n\nSet the starting value of alpha_S and the starting  renormalisation scale r2. By default alpha_S(m_Z^2) = 0.118.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.setcbt-NTuple{4, Integer}","page":"Available functions","title":"QCDNUM.setcbt","text":"setcbt(nfix, iqc, iqb, iqt)\n\nSelect FFNS or VFNS, and thresholds on mu_F^2 if necessary.\n\nArguments\n\nnfix::Integer: number of flavours in the FFNS. For VNFS set\n\nnfix = 0.\n\niqc/b/t::Integer: grid indices of the heavy flavour thresholds \n\nin the VFNS. Ignored if FFNS.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.setint-Tuple{String, Integer}","page":"Available functions","title":"QCDNUM.setint","text":"setint(param, ival)\n\nSet QCDNUM integer parameters.\n\nArguments\n\nparam::String: Name of parameter. Can be \"iter\" (number of \n\nevolutions in backwards iteration), \"tlmc\" (time-like matching  conditions), \"nopt\" (number of perturbative terms) or \"edbg\"  (evolution loop debug printout).\n\nival::Integer: Value to set.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.setlim-Tuple{Integer, Integer, Integer}","page":"Available functions","title":"QCDNUM.setlim","text":"setlim(ixmin, iqmin, iqmax)\n\nRestrict the range of a pdf evolution or import to  only part of the x-q2 grid.\n\nixmin, iqmin and iqmax re-define the range of the grid. To release a cut, eneter a value of 0. Fatal error if the cuts  result in a kinematic domain that is too small or empty.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.setlun-Tuple{Integer, String}","page":"Available functions","title":"QCDNUM.setlun","text":"setlun(lun, filename)\n\nRedirect the QCDNUM messages. Arguments are the same as for qcinit, but it can be called at any point in the program after qcinit. \n\nArguments\n\nlun::Integer: the output logical unit number. When set to 6, \n\nthe QCDNUM messages appear on the standard output. When set to -6,  the QCDNUM banner printout is suppressed.\n\nfilename::String: the output filename to store log. Irrelevant\n\nwhen lun is set to 6/-6\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.setord-Tuple{Integer}","page":"Available functions","title":"QCDNUM.setord","text":"setord(iord)\n\nSet order of perturbative QCD calculations. iord = 1, 2, 3 for LO, NLO and NNLO respectively. By default, iord = 2.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.setval-Tuple{String, Float64}","page":"Available functions","title":"QCDNUM.setval","text":"setval(param, val)\n\nSet QCDNUM parameters.\n\nArguments\n\nparam::String: Name of parameter. Can be \"null\" (result of \n\ncalc that cannot be performed), \"epsi\" (tolerance level in float comparison |x-y| < epsi), \"epsg\" (numerical accuracy of Gauss  integration in weight table calc), \"elim\" (allowed diff between  quadratic and linear spline interpolation mid-between x grid  points - to disable, set elim<=0), \"alim\" (Max allowed value of  alpha_s(mu^2)), \"qmin\" (smallest possible boundary of mu^2 grid) \"qmax\" (largest possible boundary of mu^2 grid).\n\nval::Float64: Value to set.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.splchk-Tuple{Integer, Integer, Integer}","page":"Available functions","title":"QCDNUM.splchk","text":"splchk(iset, id, iq)\n\nReturn for a basis pdf at a given Q^2 grid point the  maximum deviation between a linear interpolation and  the spline interpolation used by QCDNUM.\n\nTo be used if having issues with evolfg or extpdf.\n\nArguments\n\niset::Integer: PDF set identifier [1-24] id::Integer: Identifier of a basis PDF |e^±| iq::Integer: Index of a Q^2 grid point\n\nReturns\n\nepsi::Float64: Value of the max deviation \n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.splint_init-Tuple{SPLINTParams}","page":"Available functions","title":"QCDNUM.splint_init","text":"splint_init()\n\nHigh-level interface to splint initialisation.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ssp_erase-Tuple{Integer}","page":"Available functions","title":"QCDNUM.ssp_erase","text":"ssp_erase(ia)\n\nClear the memory from ia onwards. ia=0 can  also be used to erase all spline objects in  memory.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ssp_extrapu-Tuple{Any, Any}","page":"Available functions","title":"QCDNUM.ssp_extrapu","text":"ssp_extrapu(ia, n)\n\nDefine the extrapolation at the kinematic limit for a spline at address ia.\n\nThe extrapolation index n can be:\n\n0: constant\n1: linear\n2: quadratic\n3: cubic\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ssp_extrapv-Tuple{Any, Any}","page":"Available functions","title":"QCDNUM.ssp_extrapv","text":"ssp_extrapv(ia, n)\n\nDefine the extrapolation at the kinematic limit for a spline at address ia.\n\nThe extrapolation index n can be:\n\n0: constant\n1: linear\n2: quadratic\n3: cubic\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ssp_nprint-Tuple{Integer}","page":"Available functions","title":"QCDNUM.ssp_nprint","text":"ssp_nprint(ia)\n\nPrint a list of nodes and grids for  the spline at address ia.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ssp_s2f123-Tuple{Integer, Integer, Array{Float64, N} where N, Integer, Float64}","page":"Available functions","title":"QCDNUM.ssp_s2f123","text":"ssp_s2f123(ia, iset, def, istf, rs)\n\nFast structure function input for 2D  splines over x and qq.\n\nArguments\n\nia::Integer: address of the spline object\niset::Integer: QCDNUM pdf-set index\ndef::Array{Float64}: Array of (anti-)quark\n\ncoefficients \n\nistf::Integer: structure function index \n\n1<=>FL, 2<=>F2, 3<=>xF3, 4<=>FL'\n\nrs::Float64: sqrt(s) cut - 0 for no kinematic cut\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ssp_s2fill-Tuple{Integer, Union{Ptr{Nothing}, Base.CFunction}, Float64}","page":"Available functions","title":"QCDNUM.ssp_s2fill","text":"ssp_s2fill(iasp, fun, rs)\n\nFill the spline object by passing a function. The function  must have the signature fun(ix::Integer, iq::Integer, first::Boolean).\n\nArguments\n\niasp::Integer: address of the spline object\nfun::Union{Base.CFunction, Ptr{Nothing}}: function to be splined\nrs::Float64: set a sqrt(s) cut - 0 for no kinematic cut \n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ssp_spdump-Tuple{Integer, String}","page":"Available functions","title":"QCDNUM.ssp_spdump","text":"ssp_spdump(ia, filename)\n\nDump spline at address ia to filename.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ssp_spinit-Tuple{Integer}","page":"Available functions","title":"QCDNUM.ssp_spinit","text":"ssp_spinit(nuser)\n\nInitialise SPLINT - should be called before other  SPLINT functions.\n\nArguments\n\nnuser::Integer: the number of words reserved for user storage \n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ssp_splims-Tuple{Any}","page":"Available functions","title":"QCDNUM.ssp_splims","text":"ssp_splims(ia)\n\nGet node limits of spline at address ia.\n\nHere, u and v refer to the x and qq  dimensions respectively.\n\nReturns tuple containing\n\nnu::Integer: number of nodes in u direction\nu1::Float64: lower u limit\nu2::Float64: upper u limit\nnv::Integer: number of nodes in v direction\nv1::Float64: lower v limit\nv2::Float64: upper v limit\nn::Integer: number of active nodes below kinematic limit \n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ssp_spsetval-Tuple{Integer, Integer, Float64}","page":"Available functions","title":"QCDNUM.ssp_spsetval","text":"ssp_spsetval(ia, i, val)\n\nStore some extra info, val, along with the spline at ia.\n\nArguments\n\nia::Integer: spline address.\ni::Integer: storage index, runs from 1-100.\nval::Float64: value to store.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ssp_sqf123-Tuple{Integer, Integer, Array{Float64, N} where N, Integer, Integer}","page":"Available functions","title":"QCDNUM.ssp_sqf123","text":"ssp_sq123(ia, iset, def, istf, ix)\n\nFast structure function input for splines over qq.\n\nArguments\n\nia::Integer: address of the spline object\niset::Integer: QCDNUM pdf-set index\ndef::Array{Float64}: Array of (anti-)quark\n\ncoefficients \n\nistf::Integer: structure function index \n\n1<=>FL, 2<=>F2, 3<=>xF3, 4<=>FL'\n\nix::Integer: index of x value \n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ssp_sqfill-Tuple{Integer, Union{Ptr{Nothing}, Base.CFunction}, Integer}","page":"Available functions","title":"QCDNUM.ssp_sqfill","text":"ssp_sqfill(iasp, fun, ix)\n\nFill the 1D qq spline object by passing a function. The function  must have the signature fun(ix::Integer, iq::Integer, first::Boolean).\n\nArguments\n\niasp::Integer: address of the spline object\nfun::Union{Base.CFunction, Ptr{Nothing}}: function to be splined\nix::Integer: fixed ix value to pass to fun\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ssp_sxf123-Tuple{Integer, Integer, Array{Float64, N} where N, Integer, Integer}","page":"Available functions","title":"QCDNUM.ssp_sxf123","text":"ssp_sxf123(ia, iset, def, istf, iq)\n\nFast structure function input for splines over x.\n\nArguments\n\nia::Integer: address of the spline object\niset::Integer: QCDNUM pdf-set index\ndef::Array{Float64}: Array of (anti-)quark\n\ncoefficients \n\nistf::Integer: structure function index \n\n1<=>FL, 2<=>F2, 3<=>xF3, 4<=>FL'\n\niq::Integer: index of qq value \n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ssp_sxfill-Tuple{Integer, Union{Ptr{Nothing}, Base.CFunction}, Integer}","page":"Available functions","title":"QCDNUM.ssp_sxfill","text":"ssp_sxfill(iasp, fun, iq)\n\nFill the 1D x spline object by passing a function. The function  must have the signature fun(ix::Integer, iq::Integer, first::Boolean).\n\nArguments\n\niasp::Integer: address of the spline object\nfun::Union{Base.CFunction, Ptr{Nothing}}: function to be splined\niq::Integer: fixed iq value to pass to fun\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ssp_unodes-Tuple{Integer, Integer, Integer}","page":"Available functions","title":"QCDNUM.ssp_unodes","text":"ssp_unodes(ia, n, nu)\n\nCopy u-nodes from spline at address ia  to local array.\n\nArguments\n\nia::Integer: address of spline\nn::Integer: dimension of array to copy to\nnu::Integer: number of u-nodes copied\n\nReturns\n\narray::Array{Float64}: array of u-nodes\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ssp_uwrite-Tuple{Integer, Float64}","page":"Available functions","title":"QCDNUM.ssp_uwrite","text":"ssp_uwrite(i, val)\n\nWrite something to the reserved user space.\n\nArguments\n\ni::Integer: where to write, from 1 to nuser\nval::Float: what to write\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.ssp_vnodes-Tuple{Integer, Integer, Integer}","page":"Available functions","title":"QCDNUM.ssp_vnodes","text":"ssp_vnodes(ia, n, nv)\n\nCopy v-nodes from spline at address ia  to local array.\n\nArguments\n\nia::Integer: address of spline\nn::Integer: dimension of array to copy to\nnv::Integer: number of v-nodes copied\n\nReturns\n\narray::Array{Float64}: array of v-nodes\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.sumfij-Tuple{Integer, Array{Float64, N} where N, Integer, Integer, Integer, Integer}","page":"Available functions","title":"QCDNUM.sumfij","text":"sumfij(iset, c, isel, ix, iq, ichk)\n\nReturn the gluon or a weighted sum of quark  densities, depending on the selection flag, isel.\n\nisel values:\n\n0: Gluon density |xg> 1: Linear combination c summed over active flavours 2-8: Specific singlet/non-singlet quark component 9: Intrinsic heavy flavours  12+i: Additional pdf |xf_i> in iset\n\nSee QCDNUM manual for more information.\n\nArguments\n\niset::Integer: pdf set id (1-24).\nc::Array{Float64}: Coefficients of quarks/anti-quarks\nisel::Integer: Selection flag\nix::Integer: x grid point.\niq::Integer: q2 grid point.\nn::Integer: number of additional pdfs to be returned.\nichk::Integer: flag to steer error checking. See QCDNUM \n\ndocs. ichk = -1 makes code faster, at the risk of not  checking certain things.\n\nReturns\n\npdf::Float64: pdf value.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.sumfxq-Tuple{Integer, Array{Float64, N} where N, Integer, Float64, Float64, Integer}","page":"Available functions","title":"QCDNUM.sumfxq","text":"sumfxq(iset, c, isel, x, qmu2, ichk)\n\nReturn the gluon or a weighted sum of quark  densities, depending on the selection flag, isel.\n\nisel values:\n\n0: Gluon density |xg> 1: Linear combination c summed over active flavours 2-8: Specific singlet/non-singlet quark component 9: Intrinsic heavy flavours  12+i: Additional pdf |xf_i> in iset\n\nSee QCDNUM manual for more information.\n\nArguments\n\niset::Integer: pdf set id (1-24).\nc::Array{Float64}: Coefficients of quarks/anti-quarks\nisel::Integer: Selection flag\nx::Float64: input value of x.\nqmu2::Float64: input value of qmu2.\nn::Integer: number of additional pdfs to be returned.\nichk::Integer: flag to steer error checking. See QCDNUM \n\ndocs. ichk = -1 makes code faster, at the risk of not  checking certain things.\n\nReturns\n\npdf::Float64: pdf value.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.usepar-Tuple{Integer}","page":"Available functions","title":"QCDNUM.usepar","text":"usepar(iset)\n\nActivate the parameters of iset, ie. copy them to iset = 0 and re-initialise the active look-up tables.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.usrpdf-Tuple{Union{Ptr{Nothing}, Base.CFunction}, Integer, Integer, Float64}","page":"Available functions","title":"QCDNUM.usrpdf","text":"usrpdf(fun, iset, n, offset)\n\nCreate a user-defined type-5 pdfset (same type as the output  of evsgns). \n\nArguments\n\nfun::Union{Base.CFunction, Ptr{Nothing}}: User-defined function with the signature \n\nfun(ipdf::Integer, x::Float64, qq::Float64, first::UInt8)::Float64 specifying the values at x and qq of pdfset ipdf.\n\niset::Integer: Pdfset identifier, between 1 and 24.\nn::Integer: Number of pdf tables in addition to gluon tables.\noffset::Float64: Relative offset at the thresholds mu_h^2, used \n\nto catch matching discontinuities.\n\nReturns\n\nepsi::Float64: Maximum deviation of the quadratic spline from \n\nlinear interpolation mid-between the grid points.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.wtfile-Tuple{Integer, String}","page":"Available functions","title":"QCDNUM.wtfile","text":"wtfile(itype, filename)\n\nMaintains an up-to-date weight table in filename.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.xfrmix-Tuple{Integer}","page":"Available functions","title":"QCDNUM.xfrmix","text":"xfrmix(ix)\n\nGet x value at grid point ix.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.xxatix-Tuple{Float64, Integer}","page":"Available functions","title":"QCDNUM.xxatix","text":"xxatix(x, ix)\n\nCheck if x coincides with a grid point ix.\n\nReturns\n\nout::Bool: true or false\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.zmfillw-Tuple{}","page":"Available functions","title":"QCDNUM.zmfillw","text":"zmfillw()\n\nFill weight tables for zero-mass structure function  calculations.\n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.zmstfun-Tuple{Integer, Array{Float64, N} where N, Array{Float64, N} where N, Array{Float64, N} where N, Integer, Integer}","page":"Available functions","title":"QCDNUM.zmstfun","text":"zmstfun()\n\nCalculate a structure function from a linear combination  of parton densities.\n\nArguments\n\nistf::Integer: structure function index \n\nwhere (1,2,3,4) = (FL, F2, xF3, fL^').\n\ndef::Array{Float64}: coeffs of the quark linear combination \n\nfor which the structure function is to be calculated.\n\nx::Array{Float64}: list of x values.\nQ2::Array{Float64}: list of Q2 values.\nn::Integer: number of items in x, Q2 and f.\nichk::Integer: flag for grid boundary checks. See QCDNUM docs.\n\nReturns\n\nf::Array{Float64}: list of structure functions. \n\n\n\n\n\n","category":"method"},{"location":"functions/#QCDNUM.zmwords-Tuple{}","page":"Available functions","title":"QCDNUM.zmwords","text":"zmwords()\n\nCheck the number of words available in the ZMSTF  workspace and the number of words used.\n\n\n\n\n\n","category":"method"},{"location":"timing/","page":"Timing evolution and structure function evaluation","title":"Timing evolution and structure function evaluation","text":"EditURL = \"../../examples/timing.jl\"","category":"page"},{"location":"timing/#Timing-evolution-and-structure-function-evaluation","page":"Timing evolution and structure function evaluation","title":"Timing evolution and structure function evaluation","text":"","category":"section"},{"location":"timing/","page":"Timing evolution and structure function evaluation","title":"Timing evolution and structure function evaluation","text":"Based on the timing.f test job.","category":"page"},{"location":"timing/","page":"Timing evolution and structure function evaluation","title":"Timing evolution and structure function evaluation","text":"using QCDNUM\nusing Printf","category":"page"},{"location":"timing/","page":"Timing evolution and structure function evaluation","title":"Timing evolution and structure function evaluation","text":"Again, we start by defining the necessary inputs...","category":"page"},{"location":"timing/","page":"Timing evolution and structure function evaluation","title":"Timing evolution and structure function evaluation","text":"xmin = Float64.([1e-5, 0.2, 0.4, 0.6, 0.75])\niwt = Int32.([1, 2, 4, 8, 16])\nngx = 5\nnxin = 100\niosp = 3\nnx = 0\nqlim = Float64.([2e0, 1e4])\nwt = Float64.([1e0, 1e0])\nngq = 2\nnqin = 50\nnq = 1\nitype = 1\nfilename = \"weights/unpolarised.wgt\"\niord = 3\nas0 = 0.364\nr20 = 2.0\nq2c = 3.0\nq2b = 25.0\nq0 = 2.0\nnfin = 0\niqt = 999;\n\ndef = Float64.([0., 0., 0., 0., 0.,-1., 0., 1., 0., 0., 0., 0., 0.,\n      0., 0., 0., 0.,-1., 0., 0., 0., 1., 0., 0., 0., 0.,\n      0., 0., 0.,-1., 0., 0., 0., 0., 0., 1., 0., 0., 0.,\n      0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0.,\n      0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0.,\n      0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n      0., 0.,-1., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0.,\n      0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n      0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n      0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n      0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n      0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]);\n\nfunction func(ipdf, x)::Float64\n    i = ipdf[]\n    xb = x[]\n    adbar = 0.1939875\n    f = 0\n    if (i == 0)\n        ag = 1.7\n        f = ag * xb^-0.1 * (1.0-xb)^5.0\n    end\n    if (i == 1)\n        ad = 3.064320\n        f = ad * xb^0.8 * (1.0-xb)^4.0\n    end\n    if (i == 2)\n        au = 5.107200\n        f = au * xb^0.8 * (1.0-xb)^3.0\n    end\n    if (i == 3)\n        f = 0.0\n    end\n    if (i == 4)\n        f = adbar * xb^-0.1 * (1.0-xb)^6.0\n    end\n    if (i == 5)\n        f = adbar * xb^-0.1 * (1.0-xb)^6.0 * (1.0-xb)\n    end\n    if (i == 6)\n        xdbar = adbar * xb^-0.1 * (1.0-xb)^6.0\n        xubar = adbar * xb^-0.1 * (1.0-xb)^6.0 * (1.0-xb)\n        f = 0.2 * (xdbar + xubar)\n    end\n    if (i == 7)\n        f = 0.0\n    end\n    if (i == 8)\n        f = 0.0\n    end\n    if (i == 9)\n        f = 0.0\n    end\n    if (i == 10)\n        f = 0.0\n    end\n    if (i == 11)\n        f = 0.0\n    end\n    if (i == 12)\n        f = 0.0\n    end\n    return f\nend\n\nfunc_c = @cfunction(func, Float64, (Ref{Int32}, Ref{Float64}))\n\nproton = Float64.([4.,1.,4.,1.,4.,1.,0.,1.,4.,1.,4.,1.,4.])/9.0;\nxx = Array{Float64}(undef, 1000)\nq2 = Array{Float64}(undef, 1000)\n\nroots = 300\nshera = roots*roots\nxlog1 = log(xmin[1])\nxlog2 = log(0.99)\nqlog1 = log(qlim[1])\nqlog2 = log(qlim[ngq])\nntot = 1\nwhile (ntot < 1001)\n    rval = rand()\n    xlog = xlog1 + rval*(xlog2-xlog1)\n    xxxx = exp(xlog)\n    rval = rand()\n    qlog = qlog1 + rval*(qlog2-qlog1)\n    qqqq = exp(qlog)\n    if (qqqq <= xxxx*shera)\n        xx[ntot] = xxxx\n        q2[ntot] = qqqq\n        global ntot += 1\n    end\nend","category":"page"},{"location":"timing/","page":"Timing evolution and structure function evaluation","title":"Timing evolution and structure function evaluation","text":"Now, we set up QCDNUM and time many evolution and structure function evaluations.","category":"page"},{"location":"timing/","page":"Timing evolution and structure function evaluation","title":"Timing evolution and structure function evaluation","text":"QCDNUM.qcinit(-6, \" \")\nnx = QCDNUM.gxmake(xmin, iwt, ngx, nxin, iosp)\nnq = QCDNUM.gqmake(qlim, wt, ngq, nqin)\nnw = QCDNUM.fillwt(1)\nnw = QCDNUM.zmfillw()\nQCDNUM.setord(iord)\nQCDNUM.setalf(as0, r20)\niqc = QCDNUM.iqfrmq(q2c)\niqb = QCDNUM.iqfrmq(q2b)\nQCDNUM.setcbt(nfin, iqc, iqb, iqt)\niq0 = QCDNUM.iqfrmq(q0)\n\n@printf(\" Wait: 1000 evols and 2.10^6 stfs will take ... \")\n@time begin\n    for iter in 1:1000\n        eps = QCDNUM.evolfg(itype, func_c, def, iq0)\n        ff = QCDNUM.zmstfun(1, proton, xx, q2, 1000, 1)\n        ff = QCDNUM.zmstfun(2, proton, xx, q2, 1000, 1)\n    end\nend","category":"page"},{"location":"timing/","page":"Timing evolution and structure function evaluation","title":"Timing evolution and structure function evaluation","text":"","category":"page"},{"location":"timing/","page":"Timing evolution and structure function evaluation","title":"Timing evolution and structure function evaluation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"EditURL = \"../../examples/testsgns.jl\"","category":"page"},{"location":"testsgns/#Test-QCDNUM-evolution-options","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"","category":"section"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"We can use QCDNUM.evolfg to evolve the PDF set for all flavours, or QCDNUM.evsgns to evolve an arbitrary set of singlet/non-singlet pdfs. The latter may offer potential for external parallelisation, but first we must verify that we can use it to recreate expected results.","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"We do this by recreating the example.f demo using QCDNUM.evsgns. This is based on the testsgns.f test job.","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"using QCDNUM\nusing Printf","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"Let's start by defining some inputs","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"xmin = Float64.([1.0e-5, 0.2, 0.4, 0.6, 0.75])\niwt = Int32.([1, 2, 4, 8, 16])\nnxsubg = 5\nnxin = 100\niosp = 3\n\nqq = Float64.([2e0, 1e4])\nwt = Float64.([1e0, 1e0])\nnqin = 60\nitype = 1\nas0 = 0.364\nr20 = 2.0\n\nq2c = 3.0\nq2b = 25.0\nq2t = 1e11\nq0 = 2.0\n\ndef = Float64.([0., 0., 0., 0., 0.,-1., 0., 1., 0., 0., 0., 0., 0.,\n                0., 0., 0., 0.,-1., 0., 0., 0., 1., 0., 0., 0., 0.,\n                0., 0., 0.,-1., 0., 0., 0., 0., 0., 1., 0., 0., 0.,\n                0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0.,\n                0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0.,\n                0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n                0., 0.,-1., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0.,\n                0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n                0.,-1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0.,\n                0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n                -1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.,\n                1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0. ])\n\nisns =  Int32.([1,  2,  2,  2,  2,  2, -1, -2, -2, -2, -2, -2])\n\nnfix = 6\naar = 1.0\nbbr = 0.0;\nnothing #hide","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"Now we can state our input PDF function:","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"function func1(ipdf, x)::Float64\n    i = ipdf[]\n    xb = x[]\n    adbar = 0.1939875\n    f = 0\n    if (i == 0)\n        ag = 1.7\n        f = ag * xb^-0.1 * (1.0-xb)^5.0\n    end\n    if (i == 1)\n        ad = 3.064320\n        f = ad * xb^0.8 * (1.0-xb)^4.0\n    end\n    if (i == 2)\n        au = 5.107200\n        f = au * xb^0.8 * (1.0-xb)^3.0\n    end\n    if (i == 3)\n        f = 0.0\n    end\n    if (i == 4)\n        f = adbar * xb^-0.1 * (1.0-xb)^6.0\n    end\n    if (i == 5)\n        f = adbar * xb^-0.1 * (1.0-xb)^6.0 * (1.0-xb)\n    end\n    if (i == 6)\n        xdbar = adbar * xb^-0.1 * (1.0-xb)^6.0\n        xubar = adbar * xb^-0.1 * (1.0-xb)^6.0 * (1.0-xb)\n        f = 0.2 * (xdbar + xubar)\n    end\n    if (i == 7)\n        f = 0.0\n    end\n    if (i == 8)\n        xdbar = adbar * xb^-0.1 * (1.0-xb)^6.0\n        xubar = adbar * xb^-0.1 * (1.0-xb)^6.0 * (1.0-xb)\n        f = 0.2 * (xdbar + xubar)\n    end\n    if (i == 9)\n        f = 0.0\n    end\n    if (i == 10)\n        xdbar = adbar * xb^-0.1 * (1.0-xb)^6.0\n        xubar = adbar * xb^-0.1 * (1.0-xb)^6.0 * (1.0-xb)\n        f = 0.2 * (xdbar + xubar)\n    end\n    if (i == 11)\n        f = 0.0\n    end\n    if (i == 12)\n        xdbar = adbar * xb^-0.1 * (1.0-xb)^6.0\n        xubar = adbar * xb^-0.1 * (1.0-xb)^6.0 * (1.0-xb)\n        f = 0.2 * (xdbar + xubar)\n    end\n    return f\nend\n\nfunc1_c = @cfunction(func1, Float64, (Ref{Int32}, Ref{Float64}));\nnothing #hide","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"We can also make a function that passes an input PDF that is an output of another PDF. This will be useful later on.","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"function func2(ipdf, x)::Float64\n    i = ipdf[]\n    xb = x[]\n\n    f = 0.0\n\n    if (i == -1)\n        iset = Int(QCDNUM.qstore(\"read\", 1))\n        iq0 = Int(QCDNUM.qstore(\"read\", 2))\n    else\n        iset = Int(QCDNUM.qstore(\"read\", 1))\n        iq0 = Int(QCDNUM.qstore(\"read\", 2))\n        ix = QCDNUM.ixfrmx(xb)\n        f = QCDNUM.bvalij(iset, i, ix, iq0, 1)\n    end\n\n    return f\nend\n\nfunc2_c = @cfunction(func2, Float64, (Ref{Int32}, Ref{Float64}));\nnothing #hide","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"Now we can set up QCDNUM and print a summary of our inputs.","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"QCDNUM.qcinit(-6, \" \")\nnx = QCDNUM.gxmake(xmin, iwt, nxsubg, nxin, iosp) # make x grid\nnq = QCDNUM.gqmake(qq, wt, 2, nqin) # make qq grid\nnw = QCDNUM.fillwt(itype) # fill weight tables\nQCDNUM.setord(3) # NLO in pQCD\nQCDNUM.setalf(as0, r20) # alpha and scale\niqc = QCDNUM.iqfrmq(q2c)\niqb = QCDNUM.iqfrmq(q2b)\niqt = QCDNUM.iqfrmq(q2t)\nQCDNUM.setcbt(nfix, iqc, iqb, iqt) # FFNS and thresholds\nQCDNUM.setabr(aar, bbr) # Relationship between mu_F^2 and mu_R^2\niq0 = QCDNUM.iqfrmq(q0)","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"Print summary","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"@printf(\"xmin = %0.2e, \\t subgrids = %i\\n\", xmin[1], nxsubg)\n@printf(\"qmin = %0.2e, \\t qmax = %0.2e\\n\", qq[1], qq[2])\n@printf(\"nfix = %i, \\t\\t q2c, b, t = %0.2e, %0.2e, %0.2e\\n\", nfix, q2c, q2b, q2t)\n@printf(\"alpha = %0.2e, \\t r20 = %0.2e\\n\", as0, r20)\n@printf(\"aar = %0.2e, \\t bbr = %0.2e\\n\", aar, bbr)\n@printf(\"q20 = %0.2e\\n\", q0)","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"Evolve with QCDNUM.evolfg","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"iset1 = 1\njtype = 10*iset1+itype\neps = QCDNUM.evolfg(jtype, func1_c, def, iq0)\nQCDNUM.qstore(\"write\", 1, float(iset1))\nQCDNUM.qstore(\"write\", 2, float(iq0))","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"Evolve with QCDNUM.evsgns","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"iset2 = 2\njtype = 10*iset2+itype\nQCDNUM.setint(\"edbg\", 0) # turn off debug\neps = QCDNUM.evsgns(jtype, func2_c, isns, 12, iq0);\nnothing #hide","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"Now we can compare the results from each case, by first defining a useful function","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"function compare(jset1, jset2, id, jq, ixmin)\n\n    nx, xmi, xma, nq, qmi, qma, iord = QCDNUM.grpars()\n\n    if (jq == 0)\n        iq1 = 1\n        iq2 = nq\n        jxmin = 0\n    else\n        iq1 = jq\n        iq2 = jq\n        jxmin = ixmin\n    end\n\n    dif = 0.0\n    for iq in [iq1, iq2]\n        for ix in 1:nx\n            val1 = QCDNUM.bvalij(jset1, id, ix, iq, 1)\n            val2 = QCDNUM.bvalij(jset2, id, ix, iq, 1)\n            difi = val1-val2\n            dif = max(difi, abs(difi))\n            if (ix < jxmin)\n                println(\"(2I3,2F10.4,E13.3,2X,3I3)\")\n            end\n        end\n    end\n\n    if (jxmin == 0)\n        @printf(\"id = %i, \\t dif = %0.5e\\n\", id, dif)\n    end\n\nend\n\nfor id in 0:12\n    compare(iset1, iset2, id, 0, 1)\nend","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"","category":"page"},{"location":"testsgns/","page":"Test QCDNUM evolution options","title":"Test QCDNUM evolution options","text":"This page was generated using Literate.jl.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"EditURL = \"../../examples/quickstart.jl\"","category":"page"},{"location":"quickstart/#Quick-start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"An overview of the functionality in QCDNUM.jl","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"using QCDNUM","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Before we do anything with QCDNUM.jl, we need to initialise the QCDNUM workspace.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"QCDNUM.init(banner=true)","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Most likely we are using QCDNUM because we want to evolve a parton distribution function (PDF) over different energy scales.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"To do this, we will first need to specify the form of the input PDF at some initial energy scale. The form of the input PDF can be specified by a function together with a mapping array which tells QCDNUM the ordering of the quark species.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Let's take a look with an example PDF function:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"function input_pdf_func(ipdf, x)::Float64\n\n    # De-reference pointers\n    i = ipdf[]\n    xb = x[]\n\n    adbar = 0.1939875\n    f = 0\n\n    if (i == 0) # gluon is always i=0\n        ag = 1.7\n        f = ag * xb^-0.1 * (1.0 - xb)^5.0\n    end\n    if (i == 1) # down valence\n        ad = 3.064320\n        f = ad * xb^0.8 * (1.0 - xb)^4.0\n    end\n    if (i == 2) # up valence\n        au = 5.107200\n        f = au * xb^0.8 * (1.0 - xb)^3.0\n    end\n    if (i == 3) # strange\n        f = 0.0\n    end\n    if (i == 4) # down sea, dbar\n        f = adbar * xb^-0.1 * (1.0 - xb)^6.0\n    end\n    if (i == 5) # up sea, ubar\n        f = adbar * xb^-0.1 * (1.0 - xb)^6.0 * (1.0 - xb)\n    end\n    if (i == 6) # anti-strange, sbar\n        xdbar = adbar * xb^-0.1 * (1.0 - xb)^6.0\n        xubar = adbar * xb^-0.1 * (1.0 - xb)^6.0 * (1.0 - xb)\n        f = 0.2 * (xdbar + xubar)\n    end\n    if (i >= 7) # charm, anti-charm and heavier...\n        f = 0.0\n    end\n\n    return f\nend","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"The signature of this function is fixed by the QCDNUM interface. We also need to define the ordering, and tell QCDNUM that i=1 corresponds to the down valence component, etc. We use the following map, where the rows represent the contribution from the different quark species and the columns represent the ipdf value in the above function, from 1 to 12.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"map = Float64.([\n    #   tb  bb  cb  sb  ub  db   g   d   u   s   c   b   t\n    0, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0, 0, # 1 # U valence\n    0, 0, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 0, # 2 # D valence\n    0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, # 3 # u sea\n    0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, # 4 # d sea\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, # 5 # s\n    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, # 6 # sbar\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, # 7 # c\n    0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, # 8 # cbar\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, # 9 # b\n    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, # 10 # bbar\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, # 11\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0  # 12\n])","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"We can see that many possible PDF parametrisations are possible with this framework. QCDNUM.jl provides a simple interface, QCDNUM.InputPDF to keep track of these two components and handle the lower-level interface between julia and QCDNUM.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"input_pdf = QCDNUM.InputPDF(func=input_pdf_func, map=map)","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"To evolve this input scale, we need to define a number of evolution parameters, handled by the QCDNUM.EvolutionParams interface.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"fieldnames(QCDNUM.EvolutionParams)","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"We can check the documentation for more info on the different fields and their default values, e.g.:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"?QCDNUM.EvolutionParams.order","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"?QCDNUM.EvolutionParams.α_S","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Here, let's work with the default values. This means that out input PDF is defined for a starting scale of evolution_params.q0 with a coupling constant of evolution_params.α_S","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"evolution_params = QCDNUM.EvolutionParams()","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Another important aspect that needs to be defined is the grid of x (fractional momentum) and q2 (energy resolution scale) values. For this we have QCDNUM.GridParams, but the default values have already been set up in evolution_params.grid_params.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"evolution_params.grid_params","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Let's just stick with these for now. More details on the other parameters can be found in the documentation.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Now, we have everything we need to evolve the PDF over the specified grid. This is all taken care of with the QCDNUM.evolve function.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"ϵ = QCDNUM.evolve(input_pdf, evolution_params)","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"This function takes care of all the necessary steps and returns ϵ, which quantifies the deviation due to the interpolation between grid points, and gives a sense of the accuracy of the approximation. If ϵ > 0.1, QCDNUM will report an error.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"We can now access and plot the evolved PDF at the scale of our choice.","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"q2 = 300.0 # GeV^2\nn_additional_pdfs = 0\nerr_check_flag = 1 # Run with error checking\n\nx_grid = range(1e-3, stop=1, length=100)\nitype = evolution_params.output_pdf_loc\n\n# Select pdf with index according to above definition\n# NB -> in Julia indexing starts from 1\ng_pdf = [QCDNUM.allfxq(itype, x, q2, n_additional_pdfs, err_check_flag)[1] for x in x_grid]\ndv_pdf = [QCDNUM.allfxq(itype, x, q2, n_additional_pdfs, err_check_flag)[2] for x in x_grid]\nuv_pdf = [QCDNUM.allfxq(itype, x, q2, n_additional_pdfs, err_check_flag)[3] for x in x_grid]","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Let's also compare these with those from the input PDFs at the starting scale","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"using Plots\n\nplot(x_grid, [input_pdf.func(0, x) for x in x_grid], label=\"x g(x) - Q2 = $evolution_params.q0\",\n    lw=3, linestyle=:dash, alpha=0.5, color=:black)\nplot!(x_grid, [input_pdf.func(1, x) for x in x_grid], label=\"x dv(x) - Q2 = $evolution_params.q0\",\n    lw=3, linestyle=:dash, alpha=0.5, color=:red)\nplot!(x_grid, [input_pdf.func(2, x) for x in x_grid], label=\"x uv(x) - Q2 = $evolution_params.q0\",\n    lw=3, linestyle=:dash, alpha=0.5, color=:green)\nplot!(x_grid, g_pdf, label=\"x g(x) - Q2 = $q2\", lw=3, color=:black)\nplot!(x_grid, dv_pdf, label=\"x dv(x) - Q2 = $q2\", lw=3, color=:red)\nplot!(x_grid, uv_pdf, label=\"x uv(x) - Q2 = $q2\", lw=3, color=:green)\nplot!(xlabel=\"x\", yaxis=:log)","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"We can also save the QCDNUM setup that we used here for later use:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"QCDNUM.save_params(\"my_qcdnum_params.h5\", evolution_params)","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"Of course, these can be then be loaded back:","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"g = QCDNUM.load_params(\"my_qcdnum_params.h5\")\ng[\"evolution_params\"]","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"","category":"page"},{"location":"quickstart/","page":"Quick start","title":"Quick start","text":"This page was generated using Literate.jl.","category":"page"},{"location":"installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To use the QCDNUM.jl Julia interface to QCDNUM, you simply need to install QCDNUM.jl as described below. The compilation and linking of the original Fortran code is handled by BinaryBuilder and Yggdrasil.","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"The QCDNUM Julia wrapper can be installed either from the GitHub repository via using Julia's package manager (best if you just want to use the code) or cloned from GitHub and installed from a local directory (best if you want to develop and contribute to the source code).","category":"page"},{"location":"installation/#Simple-installation","page":"Installation","title":"Simple installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"In the Julia REPL:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using Pkg\npkg\"add QCDNUM\"","category":"page"},{"location":"installation/#Development-installation","page":"Installation","title":"Development installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"Clone the github repository, e.g. via the command line:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"git clone  https://github.com/cescalara/QCDNUM.jl.git","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Enter the directory and start Julia interpreter","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"cd QCDNUM.jl\njulia","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Open the Julia package management environment pressing .","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> ]","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Execute ","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"pkg> generate QCDNUM\n...... \npkg>  dev .","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"Exit the package manager using backspace or pressing Ctrl+C","category":"page"},{"location":"installation/#Checking-the-installation","page":"Installation","title":"Checking the installation","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"In both cases the QCDNUM package will be available via using QCDNUM. To show the available functions, execute:","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"using QCDNUM\n\nnames(QCDNUM, all=true)","category":"page"},{"location":"installation/#Package-removal","page":"Installation","title":"Package removal","text":"","category":"section"},{"location":"installation/","page":"Installation","title":"Installation","text":"To remove package execute","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> using Pkg","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"followed by ","category":"page"},{"location":"installation/","page":"Installation","title":"Installation","text":"julia> Pkg.rm(\"QCDNUM\")","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"EditURL = \"../../examples/splint.jl\"","category":"page"},{"location":"splint/#SPLINT-package-example","page":"SPLINT package example","title":"SPLINT package example","text":"","category":"section"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"SPLINT is a QCDNUM add-on for converting results computed on the evolution grid to cubic splines. This is convenient for integrating/differentiating these results.","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"using QCDNUM\nusing Printf","category":"page"},{"location":"splint/#Example-evolution-grid","page":"SPLINT package example","title":"Example evolution grid","text":"","category":"section"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"First, we need a QCDNUM evolution grid to work with. For this, we use the QCDNUM example program described in the example notebook.","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"xmin = Float64.([1.0e-4])\niwt = Int32.([1])\nng = 1\nnxin = 100\niosp = 3\nnx = 10\n\nqq = Float64.([2e0, 1e4])\nwt = Float64.([1e0, 1e0])\nnq = 1\nnqin = 60\nngq = 2\nitype = 1\n\nas0 = 0.364\nr20 = 2.0\n\nq2c = 3.0\nq2b = 25.0\nq0 = 2.0\niqt = 999\n\ndef = Float64.([0., 0., 0., 0., 0.,-1., 0., 1., 0., 0., 0., 0., 0.,\n      0., 0., 0., 0.,-1., 0., 0., 0., 1., 0., 0., 0., 0.,\n      0., 0., 0.,-1., 0., 0., 0., 0., 0., 1., 0., 0., 0.,\n      0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0.,\n      0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0.,\n      0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n      0., 0.,-1., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0.,\n      0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n      0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n      0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n      0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n      0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]);\n\nnfin = 0\nx = 1.0e-3\nq = 1.0e3\npdf = Array{Float64}(undef, 13)\nqmz2 = 8315.25;\n\nfunction func(ipdf, x)::Float64\n    i = ipdf[]\n    xb = x[]\n    adbar = 0.1939875\n    f = 0\n    if (i == 0)\n        ag = 1.7\n        f = ag * xb^-0.1 * (1.0-xb)^5.0\n    end\n    if (i == 1)\n        ad = 3.064320\n        f = ad * xb^0.8 * (1.0-xb)^4.0\n    end\n    if (i == 2)\n        au = 5.107200\n        f = au * xb^0.8 * (1.0-xb)^3.0\n    end\n    if (i == 3)\n        f = 0.0\n    end\n    if (i == 4)\n        f = adbar * xb^-0.1 * (1.0-xb)^6.0\n    end\n    if (i == 5)\n        f = adbar * xb^-0.1 * (1.0-xb)^6.0 * (1.0-xb)\n    end\n    if (i == 6)\n        xdbar = adbar * xb^-0.1 * (1.0-xb)^6.0\n        xubar = adbar * xb^-0.1 * (1.0-xb)^6.0 * (1.0-xb)\n        f = 0.2 * (xdbar + xubar)\n    end\n    if (i == 7)\n        f = 0.0\n    end\n    if (i == 8)\n        f = 0.0\n    end\n    if (i == 9)\n        f = 0.0\n    end\n    if (i == 10)\n        f = 0.0\n    end\n    if (i == 11)\n        f = 0.0\n    end\n    if (i == 12)\n        f = 0.0\n    end\n    return f\nend\n\nfunc_c = @cfunction(func, Float64, (Ref{Int32}, Ref{Float64}))","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"Let's set up and run this example evolution.","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"QCDNUM.qcinit(-6, \" \")\nnx = QCDNUM.gxmake(xmin, iwt, ng, nxin, iosp)\nnq = QCDNUM.gqmake(qq, wt, ngq, nqin)\nnw = QCDNUM.fillwt(itype)\nQCDNUM.setord(3)\nQCDNUM.setalf(as0, r20)\niqc = QCDNUM.iqfrmq(q2c)\niqb = QCDNUM.iqfrmq(q2b)\niqt = QCDNUM.iqfrmq(1e11)\nQCDNUM.setcbt(0, iqc, iqb, 0)\niq0 = QCDNUM.iqfrmq(q0)\neps = QCDNUM.evolfg(itype, func_c, def, iq0)\npdf = QCDNUM.allfxq(itype, x, q, 0, 1)\nasmz, a, b = QCDNUM.asfunc(qmz2)\ncsea = 2*pdf[3];\n\n@printf(\"x, q, CharmSea = %0.4e, %0.4e, %0.4e\\n\", x, q, csea)\n@printf(\"as(mz2) = %0.4e\", asmz)","category":"page"},{"location":"splint/#SPLINT","page":"SPLINT package example","title":"SPLINT","text":"","category":"section"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"For the SPLINT example, we need a PDF stored and the corresponding iset and ipdf. We will use this to input the function to spline.","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"iset = itype\nipdf = 1; # component of PDF, -6 to 6\n\nQCDNUM.fvalij(iset, ipdf, 1, 1, 1) # check we get values","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"Now that we have run the example program, we can load SPLINT, and write iset and ipdf to the user space.","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"QCDNUM.ssp_spinit(100)\nQCDNUM.ssp_uwrite(1, Float64(iset))\nQCDNUM.ssp_uwrite(2, Float64(ipdf))","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"Make spline object","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"iasp = QCDNUM.isp_s2make(5, 5)","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"Define function to read from QCDNUM into spline","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"function func(ix, iq, first)::Float64\n\n    ix = ix[] # deref ptr\n    iq = iq[]\n\n    iset = Int32(QCDNUM.dsp_uread(1))\n    ipdf = Int32(QCDNUM.dsp_uread(2))\n\n    return QCDNUM.fvalij(iset, ipdf, ix, iq, 1)\nend\n\nfun = @cfunction(func, Float64, (Ref{Int32}, Ref{Int32}, Ref{UInt8}))","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"Fill the spline and set no kinematic limit","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"QCDNUM.ssp_s2fill(iasp, fun, 0.0)","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"We can use some helper functions to query the spline properties...","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"QCDNUM.isp_splinetype(iasp)\n\nnu, u1, u2, nv, v1, v2, n = QCDNUM.ssp_splims(iasp)","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"... or copy the nodes locally and print a summary.","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"xarray = QCDNUM.ssp_unodes(iasp, nu, nu);\nqqarray = QCDNUM.ssp_vnodes(iasp, nv, nv);\n\nQCDNUM.ssp_nprint(iasp)","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"There are routines to evaluate the function and its integral at desired x and qq values/ranges.","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"x = 0.1\nq = 100.0\nQCDNUM.dsp_funs2(iasp, x, q, 1)\n\nx1 = 0.01\nx2 = 0.1\nq1 = 10.0\nq2 = 100.0\nrs = 370.0\nnp = 4\nQCDNUM.dsp_ints2(iasp, x1, x2, q1, q2, rs, np)","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"It is also possible to set user nodes, if the automatically chosen ones are not satisfactory.","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"xarr = Float64.([1e-2, 5e-2, 1e-1, 0.5])\nqarr = Float64.([10, 1e2, 1e3, 5e3])\nnx = length(xarr)\nnq = length(qarr)\n\niasp = QCDNUM.isp_s2user(xarr, nx, qarr, nq)","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"Let's check the update nodes:","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"QCDNUM.ssp_nprint(iasp)","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"","category":"page"},{"location":"splint/","page":"SPLINT package example","title":"SPLINT package example","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Fast QCD evolution and convolution: QCDNUM.jl solves the DGLAP evolution equations, which describe the evolution of parton distribution functions with varying energy scales. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Hadrons, such as protons and neutrons, are made up of quarks held together by the strong force. At high energy scales, the valence quarks that define these hadrons exist in a sea of virtual quarks and gluons. The parton distribution functions (often abbreviated to PDFs) describe this structure and are of fundamental importance to our understanding of quantum chromodynamics (QCD), as well as its application to a rnage of processes, from LHC physics to the development of cosmic ray air showers in the Earth's atmosphere. PDFs can be extracted from accelerator measurements in which hadrons are probed through collisions with electrons, and the DGLAP equations are widely used for this purpose.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"QCDNUM.jl is a Julia wrapper for Michiel Botje's QCDNUM, written in Fortran77. The Julia interface offers several interesting advantages:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Easily install and use the original QCDNUM without having to compile it on your system - all set up is taken care of behind the scenes in a cross-platform way thanks to BinaryBuilder and Yggdrasil\nInterface your QCDNUM-based code with Julia's rich functionality and package ecosystem \nWork interactively with easy file IO, plotting and debugging in e.g. Jupyter notebooks\nWrite more accessible code with the high-level Julia interface provided, in addition to all functions available in QCDNUM","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Have you not used QCDNUM before, but are interested to see what QCDNUM.jl can do? Our high-level Julia interface may be more accessible for you. Check out the quick start example where we demonstrate the main functionality.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Are you a long-time user of QCDNUM in Fortran or C++? All the standard QCDNUM functions have corresponding Julia versions. So, translating your old code or starting a new project should be a quick and intuitive! Check out the QCDNUM example jobs. These are Julia versions of the test jobs of the original QCDNUM. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The source code, along with Julia scripts for all examples can be found in the GitHub repository.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This documentation gives an overview of the Julia implementation. More details can be found in the QCDNUM docs.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If you are interested in extracting parton densities from accelerator data, you may want to check out our PartonDensity.jl project.","category":"page"},{"location":"#Citation","page":"Introduction","title":"Citation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Original QCDNUM software: M. Botje, Comput. Phys. Commun. 182(2011)490, arXiv:1005.1481. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"QCDNUM.jl: Coming soon!","category":"page"},{"location":"notebook/#Use-QCDNUM-in-Jupyter-notebook","page":"Notebook tutorial","title":"Use QCDNUM in Jupyter notebook","text":"","category":"section"},{"location":"notebook/","page":"Notebook tutorial","title":"Notebook tutorial","text":"The simplest way to use the QCDNUM in the Jupyter notebook after the installation is ","category":"page"},{"location":"notebook/","page":"Notebook tutorial","title":"Notebook tutorial","text":"To create a virtual python environment with an ad-hoc name myjuliav","category":"page"},{"location":"notebook/","page":"Notebook tutorial","title":"Notebook tutorial","text":"[user@host workdirectory]$ python -m venv myjuliav","category":"page"},{"location":"notebook/","page":"Notebook tutorial","title":"Notebook tutorial","text":"Activate the virtual environment","category":"page"},{"location":"notebook/","page":"Notebook tutorial","title":"Notebook tutorial","text":"[user@host workdirectory]$ source myjuliav/bin/activate.sh","category":"page"},{"location":"notebook/","page":"Notebook tutorial","title":"Notebook tutorial","text":"Install the Jupyter notebook package using pip","category":"page"},{"location":"notebook/","page":"Notebook tutorial","title":"Notebook tutorial","text":"(myjuliav) [user@host workdirectory]$ python -m pip install notebook","category":"page"},{"location":"notebook/","page":"Notebook tutorial","title":"Notebook tutorial","text":"Launch the notebook ","category":"page"},{"location":"notebook/","page":"Notebook tutorial","title":"Notebook tutorial","text":"(myjuliav) [user@host workdirectory]$ jupyter notebook","category":"page"},{"location":"notebook/","page":"Notebook tutorial","title":"Notebook tutorial","text":"and follow the instructions that will be shown on the screen.","category":"page"},{"location":"notebook/#In-the-notebook","page":"Notebook tutorial","title":"In the notebook","text":"","category":"section"},{"location":"notebook/","page":"Notebook tutorial","title":"Notebook tutorial","text":"Create a new  notebook ","category":"page"},{"location":"notebook/","page":"Notebook tutorial","title":"Notebook tutorial","text":"(Image: New notebook)","category":"page"},{"location":"notebook/","page":"Notebook tutorial","title":"Notebook tutorial","text":"Start to use QCDNUM","category":"page"},{"location":"notebook/","page":"Notebook tutorial","title":"Notebook tutorial","text":"(Image: QCDNUM)","category":"page"},{"location":"example/","page":"QCDNUM example program","title":"QCDNUM example program","text":"EditURL = \"../../examples/example.jl\"","category":"page"},{"location":"example/#QCDNUM-example-program","page":"QCDNUM example program","title":"QCDNUM example program","text":"","category":"section"},{"location":"example/","page":"QCDNUM example program","title":"QCDNUM example program","text":"Based on example.f detailed here.","category":"page"},{"location":"example/","page":"QCDNUM example program","title":"QCDNUM example program","text":"using QCDNUM\nusing Printf","category":"page"},{"location":"example/","page":"QCDNUM example program","title":"QCDNUM example program","text":"Let's define some useful inputs","category":"page"},{"location":"example/","page":"QCDNUM example program","title":"QCDNUM example program","text":"xmin = Float64.([1.0e-4])\niwt = Int32.([1])\nng = 1\nnxin = 100\niosp = 3\nnx = 10\n\nqq = Float64.([2e0, 1e4])\nwt = Float64.([1e0, 1e0])\nnq = 1\nnqin = 60\nngq = 2\nitype = 1\n\nas0 = 0.364\nr20 = 2.0\n\nq2c = 3.0\nq2b = 25.0\nq0 = 2.0\niqt = 999\n\ndef = Float64.([0., 0., 0., 0., 0.,-1., 0., 1., 0., 0., 0., 0., 0.,\n                0., 0., 0., 0.,-1., 0., 0., 0., 1., 0., 0., 0., 0.,\n                0., 0., 0.,-1., 0., 0., 0., 0., 0., 1., 0., 0., 0.,\n                0., 0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0.,\n                0., 0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0.,\n                0., 0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n                0., 0.,-1., 0., 0., 0., 0., 0., 0., 0., 1., 0., 0.,\n                0., 0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n                0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n                0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n                0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n                0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.]);\n\nnfin = 0\nx = 1.0e-3\nq = 1.0e3\npdf = Array{Float64}(undef, 13)\nqmz2 = 8315.25;\nnothing #hide","category":"page"},{"location":"example/","page":"QCDNUM example program","title":"QCDNUM example program","text":"Now, we can define the input PDF function for the PDF we would like to evolve. We also then have to use the Julia @cfunction macro so that we can pass it to QCDNUM through the wrapper.","category":"page"},{"location":"example/","page":"QCDNUM example program","title":"QCDNUM example program","text":"function func(ipdf, x)::Float64\n    i = ipdf[]\n    xb = x[]\n    adbar = 0.1939875\n    f = 0\n    if (i == 0)\n        ag = 1.7\n        f = ag * xb^-0.1 * (1.0-xb)^5.0\n    end\n    if (i == 1)\n        ad = 3.064320\n        f = ad * xb^0.8 * (1.0-xb)^4.0\n    end\n    if (i == 2)\n        au = 5.107200\n        f = au * xb^0.8 * (1.0-xb)^3.0\n    end\n    if (i == 3)\n        f = 0.0\n    end\n    if (i == 4)\n        f = adbar * xb^-0.1 * (1.0-xb)^6.0\n    end\n    if (i == 5)\n        f = adbar * xb^-0.1 * (1.0-xb)^6.0 * (1.0-xb)\n    end\n    if (i == 6)\n        xdbar = adbar * xb^-0.1 * (1.0-xb)^6.0\n        xubar = adbar * xb^-0.1 * (1.0-xb)^6.0 * (1.0-xb)\n        f = 0.2 * (xdbar + xubar)\n    end\n    if (i == 7)\n        f = 0.0\n    end\n    if (i == 8)\n        f = 0.0\n    end\n    if (i == 9)\n        f = 0.0\n    end\n    if (i == 10)\n        f = 0.0\n    end\n    if (i == 11)\n        f = 0.0\n    end\n    if (i == 12)\n        f = 0.0\n    end\n    return f\nend\n\nfunc_c = @cfunction(func, Float64, (Ref{Int32}, Ref{Float64}))","category":"page"},{"location":"example/","page":"QCDNUM example program","title":"QCDNUM example program","text":"Next, let's initialise QCDNUM and run QCDNUM to evolve the PDF.","category":"page"},{"location":"example/","page":"QCDNUM example program","title":"QCDNUM example program","text":"QCDNUM.qcinit(-6, \" \")\nnx = QCDNUM.gxmake(xmin, iwt, ng, nxin, iosp)\nnq = QCDNUM.gqmake(qq, wt, ngq, nqin)\nnw = QCDNUM.fillwt(itype)\nQCDNUM.setord(3)\nQCDNUM.setalf(as0, r20)\niqc = QCDNUM.iqfrmq(q2c)\niqb = QCDNUM.iqfrmq(q2b)\niqt = QCDNUM.iqfrmq(1e11)\nQCDNUM.setcbt(0, iqc, iqb, 0)\niq0 = QCDNUM.iqfrmq(q0)\neps = QCDNUM.evolfg(itype, func_c, def, iq0)\npdf = QCDNUM.allfxq(itype, x, q, 0, 1)\nasmz, a, b = QCDNUM.asfunc(qmz2)\ncsea = 2*pdf[3];\nnothing #hide","category":"page"},{"location":"example/","page":"QCDNUM example program","title":"QCDNUM example program","text":"Now, we can briefly check the results","category":"page"},{"location":"example/","page":"QCDNUM example program","title":"QCDNUM example program","text":"@printf(\"x, q, CharmSea = %0.4e, %0.4e, %0.4e\\n\", x, q, csea)\n@printf(\"as(mz2) = %0.4e\", asmz)","category":"page"},{"location":"example/","page":"QCDNUM example program","title":"QCDNUM example program","text":"","category":"page"},{"location":"example/","page":"QCDNUM example program","title":"QCDNUM example program","text":"This page was generated using Literate.jl.","category":"page"}]
}
